# 基础定义

- 认证（登录） 
    - 用户名 + 密码（+ 验证码）
    - 用户标识 + 验证码自由组合（如 手机号 + 短信验证码、用户名加短信验证码、用户名 + 邮件验证码）
    - OIDC：基于 oauth2.0 + jwt 认证实现 `SSO`（单点登录/登出）
    
- 授权 Oauth2.0
    - 模式：采取主流、功能最完善的 授权码模式


响应的 JSON 推荐为
```json
{
"code":"int",
"data":"object",
"msg":"string"
}
```
本框架仅依赖 msg 字段，即默认的响应为
```json
{
"msg":"xxx"
}
```

---
## spring security 用户登录为什么用过滤器？
保证只有认证（登录）成功的用户才能访问服务器，无论是接口还是该应用的静态文件



## jwt退出登录的解决方案

### 治标
- 只让前端清理token，后端不理会。（大多数场景）
    
### 治本
- Token 黑名单
    - 退出登录时，将token放入黑名单中（清理规则：黑名单过期时间晚于 token 失效时间）
    - 每次请求校验token前判断是否在黑名单

- Token中附带`用户版本号`
    - 登录时token附带版本号
    - 用户登出的时候在redis中把用户对应的版本号加一
    - 访问时从token中取出 `用户id` 和 `版本号` 和 redis中存储的做对比，不一致则不给访问

- Token中附带创建时间
    - 登录时token附带创建时间
    - 退出时在 redis 存储该 token 的过期时间（清理规则：过期时间晚于 token 失效时间）
    - 访问时校验redis存储的过期时间，如果创建时间大于过期时间则不给访问

- 服务端存储 token 副本
    - 登录时服务端（在redis中）存储token副本
    - 退出时删除 token 副本
    - 用户请求时候校验是否存在副本，若不存在则不通过

## jwt 控制登录人数

- Token中附带`用户版本号`
    - 当前版本号 - token版本号是 < 单个账号最大登录人数
    - 方便实现强制下线等操作